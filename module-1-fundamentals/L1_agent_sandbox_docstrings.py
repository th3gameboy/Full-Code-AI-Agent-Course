import os                     # For interacting with the operating system
import openai                 # For interacting with OpenAI's API
from dotenv import load_dotenv  # To load environment variables from a .env file

# Load environment variables from the .env file (e.g., OPENAI_API_KEY)
load_dotenv()

# Initialize the OpenAI API key from the environment variable
openai.api_key = os.getenv("OPENAI_API_KEY")
# If the API key is missing, raise an error to alert the user
if not openai.api_key:
    raise ValueError("OpenAI API key not found! Please set OPENAI_API_KEY in .env.")

class Agent:
    """
    A basic AI agent that generates a response based on user input.
    It creates a plan, executes each step of the plan, and synthesizes the results into a final answer.
    """

    def __init__(self, name="Agent"):
        """
        Initialize the Agent with a name and set an initial status.
        
        Parameters:
            name (str): The name for the agent. Defaults to "Agent".
        """
        self.name = name               # Use the provided name (default is "Agent")
        self.status = "idle"           # Agent status (e.g., idle, planning, executing)

    def generate_response(self, user_input):
        """
        Generate a final answer based on the user input.
        
        This method:
          1. Strips the input and checks if it's empty.
          2. Sets the status to planning and creates a plan.
          3. Sets the status to executing and executes each step of the plan.
          4. Sets the status to completed and synthesizes the results.
        
        Parameters:
            user_input (str): The input provided by the user.
        
        Returns:
            str: The final synthesized answer or an error message.
        """
        try:
            cleaned_input = user_input.strip()  # Remove leading/trailing whitespace
            if not cleaned_input:
                return "No input provided!"     # Return a message if input is empty

            print("\nProcessing...")
            self.status = "planning"             # Set status to planning
            print("Status: Planning response...")
            plan_text = self._create_plan(cleaned_input)  # Create a plan based on the user input

            # Check that the plan is not empty
            if not plan_text:
                raise ValueError("Plan creation returned no result.")

            self.status = "executing"            # Set status to executing
            print("Status: Executing plan...")
            partial_results = self._execute_plan(plan_text, cleaned_input)  # Execute each step

            self.status = "completed"            # Set status to completed
            final_answer = self._synthesize_results(partial_results)  # Synthesize the partial results
            return final_answer                   # Return the final answer

        except Exception as e:
            self.status = "error"                # Update status on error
            return "Agent encountered an error: " + str(e)

    def _create_plan(self, user_input):
        """
        Create a plan by asking the LLM to list steps to handle the user input.
        
        Parameters:
            user_input (str): The cleaned user input.
        
        Returns:
            str: The plan text generated by the LLM.
        """
        prompt = (
            "I am an AI agent. The user input is:\n"
            f"'{user_input}'\n\n"
            "Please list 1-3 steps (each on a new line) that I should do to handle this input.\n"
            "Example:\n"
            "1. Understand the user's question\n"
            "2. Research the topic\n"
            "3. Provide a clear answer\n"
        )
        # Call the LLM with the prompt to generate the plan
        plan_response = self._call_llm(prompt)  # API Call to generate the plan
        return plan_response  # Return the plan text

    def _parse_plan(self, plan_text):
        """
        Parse the plan text into a list of individual steps.
        
        Splits the plan text by newlines and removes any empty lines.
        
        Parameters:
            plan_text (str): The text containing the plan steps.
        
        Returns:
            list: A list of non-empty plan steps.
        """
        # Split the plan text by newlines and remove empty lines
        lines = plan_text.split("\n")
        steps = []
        for line in lines:
            step = line.strip()
            if step:
                steps.append(step)
        return steps

    def _execute_plan(self, plan_text, user_input):
        """
        Execute each step in the plan by calling the LLM for each step.
        
        Each step is wrapped in its own try/except block so that if one step fails,
        the rest of the plan can still be executed.
        
        Parameters:
            plan_text (str): The complete plan text from the LLM.
            user_input (str): The original user input.
        
        Returns:
            list: A list of results (or error messages) for each step.
        """
        # Use the helper method to break the plan into steps
        steps = self._parse_plan(plan_text)
        results = []  # List to store the results of each step

        # Iterate over each step in the plan
        for step in steps:
            try:
                # Define the prompt for this step, including the original user input
                step_prompt = (
                    f"Step: {step}\n\n"
                    f"User Input: '{user_input}'\n\n"
                    "Please do this step and provide the result."
                )
                # Call the LLM with the step prompt to execute the step
                result = self._call_llm(step_prompt)  # API Call for this step
                # Append the step and its result to the results list
                results.append(f"Step: {step}\nResult: {result}")
            except Exception as e:
                # If an error occurs for this step, record an error message but continue
                results.append(f"Step: {step}\nResult: Error executing this step: {e}")
            # End try/except for each step
        return results  # Return all the partial results

    def _synthesize_results(self, partial_results):
        """
        Synthesize all partial results into a final answer.
        
        Combines the results from the execution stage into a single prompt and
        asks the LLM to generate a clear, direct final answer.
        
        Parameters:
            partial_results (list): The list of results from each executed step.
        
        Returns:
            str: The final synthesized answer.
        """
        synthesis_prompt = (
            "Here are the partial results from each step:\n\n"
            + "\n\n".join(partial_results)
            + "\n\nProvide a single, clear paragraph that synthesizes these results into a direct and complete response." 
        )
        # Call the LLM with the synthesis prompt to generate the final answer
        final_answer = self._call_llm(synthesis_prompt)  # API Call for synthesis
        return final_answer  # Return the final answer

    def _call_llm(self, prompt):
        """
        Call the OpenAI LLM with the provided prompt and return the text response.
        
        Parameters:
            prompt (str): The prompt to send to the LLM.
        
        Returns:
            str: The content from the LLM's response.
        """
        response = openai.ChatCompletion.create(
            model="gpt-4o",  # Specify the model to use
            messages=[
                {"role": "system", "content": "You are a helpful AI agent."},
                {"role": "user", "content": prompt}
            ],
            temperature=0.7,  # Set creativity level
            max_tokens=1000   # Limit the response length
        )
        # Extract and return the text from the LLM response, removing any extra whitespace
        return response.choices[0].message.content.strip()

def main():
    """
    Run the AI Agent Interface.
    
    Creates an instance of Agent, clears the screen, displays a welcome message,
    and enters a loop to continuously get user input and generate responses until 'quit' is entered.
    """
    # Create an instance of the Agent
    agent = Agent(name="Agent")
    # Clear the screen (works for Windows and Unix-like systems)
    os.system('cls' if os.name == 'nt' else 'clear')
    print("""Welcome to the AI Agent Interface!
--------------------------------
This agent can help answer your questions and assist with various tasks.
Simply type your question or request, and the agent will respond.
Examples:
- 'What is Python?'
- 'How do I start learning programming?'
- 'Explain what an API is'
Type 'quit' to exit the program.
--------------------------------""")

    while True:
        user_input = input("User: ")      # Get input from the user
        if user_input.lower() == "quit":    # Check if the user wants to exit
            print("Goodbye!")
            break

        # Generate and display the agent's response along with its current status
        response = agent.generate_response(user_input)  # May involve multiple API calls
        print(f"\n{agent.name}: {response}\n(Agent status: {agent.status})")

if __name__ == "__main__":
    main()  # Call the main function to start the program
